package main

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/davecgh/go-spew/spew"
	"github.com/jessevdk/go-flags"
	"github.com/pkg/errors"
	"github.com/reddec/fluent-amqp"
	"github.com/streadway/amqp"
	"io/ioutil"
	"log"
	"os"
	"time"
)

var (
	version = "dev"
)

var config struct {
	URLs         []string `short:"u" long:"url"                env:"BROKER_URL"         description:"One or more AMQP brokers urls" default:"amqp://guest:guest@localhost" required:"yes"`
	Exchange     string   `short:"e" long:"exchange"           env:"BROKER_EXCHANGE"    description:"Name of AMQP exchange. Can be empty"`
	ExchangeType string   `short:"k" long:"kind"               env:"BROKER_KIND"        description:"Exchange kind" choice:"direct" choice:"topic" choice:"fanout" default:"direct"`
	Verify       string   `short:"s" long:"verify-public-cert" env:"BROKER_SIGN"        description:"Path to public cert to verify"`
	Queue        string   `short:"Q" long:"queue"              env:"BROKER_QUEUE"       description:"Queue name or empty for autogenerated"`
	Lazy         bool     `short:"l" long:"lazy"               env:"BROKER_LAZY"        description:"Make queue lazy (prefer keep data on disk)"`
	OutType      string   `short:"o" long:"output"             env:"BROKER_OUTPUT"      description:"Output type" choice:"body" choice:"dump" choice:"json" default:"body"`
	Args         struct {
		RoutingKey string `positional-arg-name:"routing-key" env:"BROKER_ROUTING_KEY" description:"Routing key"`
	} `positional-args:"yes"`

	Interval time.Duration `short:"R" long:"reconnect-interval" env:"BROKER_RECONNECT_INTERVAL" description:"Reconnect timeout" default:"5s"`
	Timeout  time.Duration `short:"T" long:"timeout" env:"BROKER_CONNECT_TIMEOUT" description:"Connect timeout" default:"30s"`

	Quiet   bool `short:"q" long:"quiet" env:"BROKER_QUIET" description:"Suppress all log messages"`
	Version bool `short:"v" long:"version" description:"Print version and exit"`
}

func run() error {
	gctx, cancel := context.WithCancel(context.Background())
	ctx := fluent.SignalContext(gctx)
	broker := fluent.Broker(config.URLs...).Context(ctx).Logger(log.New(os.Stderr, "[broker] ", log.LstdFlags)).Interval(config.Interval).Timeout(config.Timeout).Start()
	defer broker.WaitToFinish()
	defer cancel()
	log.Println("preparing sink")
	publisherCfg := broker.Sink(config.Queue)
	if config.Verify != "" {
		log.Println("preparing validator")
		publisherCfg = publisherCfg.Validate(config.Verify)
	}
	if config.Lazy {
		publisherCfg = publisherCfg.Lazy()
	}
	handler := func(ctx context.Context, msg amqp.Delivery) {
		defer cancel()
		switch config.OutType {
		case "dump":
			spew.Dump(msg)
		case "json":
			dec := json.NewEncoder(os.Stdout)
			dec.SetIndent("", "  ")
			dec.Encode(&msg)
		case "body", "plain":
			os.Stdout.Write(msg.Body)
		default:
			panic("unknown output format")
		}
	}

	var exc *fluent.Exchange
	if config.Exchange != "" {
		switch config.ExchangeType {
		case "topic":
			exc = publisherCfg.Topic(config.Exchange)
		case "direct":
			exc = publisherCfg.Direct(config.Exchange)
		case "fanout":
			exc = publisherCfg.Fanout(config.Exchange)
		default:
			return errors.Errorf("unknown exchange type %v", config.ExchangeType)
		}

		if config.Args.RoutingKey != "" {
			exc = exc.Key(config.Args.RoutingKey)
		}

		exc.HandlerFunc(handler)
	} else {
		publisherCfg.HandlerFunc(handler)
	}
	log.Println("reader prepared")
	log.Println("waiting for messages...")
	broker.WaitToFinish()
	return nil
}

func main() {
	parser := flags.NewParser(&config, flags.Default)
	_, err := parser.Parse()
	if config.Version {
		fmt.Println(version)
		return
	}
	if err != nil {
		os.Exit(1)
	}
	if config.Quiet {
		log.SetOutput(ioutil.Discard)
	}
	err = run()
	if err != nil {
		log.Println("failed:", err)
		os.Exit(2)
	}
}
