package main

import (
	"bytes"
	"context"
	"fmt"
	"github.com/jessevdk/go-flags"
	"github.com/pkg/errors"
	"github.com/reddec/fluent-amqp"
	"github.com/streadway/amqp"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"strconv"
	"time"
)

var (
	version = "dev"
)
var config struct {
	URLs         []string      `short:"u" long:"url"                env:"BROKER_URL"         description:"One or more AMQP brokers urls" default:"amqp://guest:guest@localhost" required:"yes"`
	Exchange     string        `short:"e" long:"exchange"           env:"BROKER_EXCHANGE"    description:"Name of AMQP exchange. Can be empty"`
	ExchangeType string        `short:"k" long:"kind"               env:"BROKER_KIND"        description:"Exchange kind" choice:"direct" choice:"topic" choice:"fanout" default:"direct"`
	Verify       string        `short:"s" long:"verify-public-cert" env:"BROKER_SIGN"        description:"Path to public cert to verify"`
	Queue        string        `short:"Q" long:"queue"              env:"BROKER_QUEUE"       description:"Queue name or empty for autogenerated"`
	Lazy         bool          `short:"l" long:"lazy"               env:"BROKER_LAZY"        description:"Make queue lazy (prefer keep data on disk)"`
	Interval     time.Duration `short:"R" long:"reconnect-interval" env:"BROKER_RECONNECT_INTERVAL" description:"Reconnect timeout" default:"5s"`
	RetryLimit   int           `long:"retry-limit" env:"RETRY_LIMIT" description:"Number of retries (-1 is infinite)" default:"-1"`
	Timeout      time.Duration `short:"T" long:"timeout" env:"BROKER_CONNECT_TIMEOUT" description:"Connect timeout" default:"30s"`
	Quiet        bool          `short:"q" long:"quiet" env:"BROKER_QUIET" description:"Suppress all log messages"`
	Version      bool          `short:"v" long:"version" description:"Print version and exit"`
	RoutingKey   []string      `short:"r" long:"routing-key"  env-delim:"," env:"BROKER_ROUTING_KEY" description:"Routing key"`
	Args         struct {
		App    string   `positional-arg-name:"application" env:"APP" description:"Application executable" required:"yes"`
		Params []string `positional-arg-name:"params" env:"PARAMS" env-delim:" "  description:"Application executable params"`
	} `positional-args:"yes"`
}

var logOutput io.Writer = os.Stderr

func run() error {
	gctx, cancel := context.WithCancel(context.Background())
	ctx := fluent.SignalContext(gctx)
	broker := fluent.Broker(config.URLs...).Context(ctx).Logger(log.New(logOutput, "[broker] ", log.LstdFlags)).Interval(config.Interval).Timeout(config.Timeout).Start()
	defer broker.WaitToFinish()
	defer cancel()
	log.Println("preparing sink")
	publisherCfg := broker.Sink(config.Queue).Retries(config.RetryLimit)
	if config.Verify != "" {
		log.Println("preparing validator")
		publisherCfg = publisherCfg.Validate(config.Verify)
	}
	if config.Lazy {
		publisherCfg = publisherCfg.Lazy()
	}

	var exc *fluent.Exchange

	publisher := broker.Publisher().Create()

	if config.Exchange != "" {
		switch config.ExchangeType {
		case "topic":
			exc = publisherCfg.Topic(config.Exchange)
		case "direct":
			exc = publisherCfg.Direct(config.Exchange)
		case "fanout":
			exc = publisherCfg.Fanout(config.Exchange)
		default:
			return errors.Errorf("unknown exchange type %v", config.ExchangeType)
		}
		exc = exc.Key(config.RoutingKey...)

		exc.TransactFunc(makeHandler(publisher))
	} else {
		publisherCfg.TransactFunc(makeHandler(publisher))
	}
	log.Println("reader prepared")
	log.Println("waiting for messages...")
	broker.WaitToFinish()
	return nil
}

func makeHandler(publisher *fluent.Writer) fluent.TransactionHandlerFunc {
	return func(ctx context.Context, msg amqp.Delivery) error {
		data, err := runApplication(ctx, &msg)
		if err != nil {
			return err
		}
		if msg.ReplyTo != "" {
			return publisher.Reply(&msg).Bytes(data).PublishWait(ctx)
		}
		return nil
	}
}

func main() {
	parser := flags.NewParser(&config, flags.Default)
	_, err := parser.Parse()
	if config.Version {
		fmt.Println(version)
		return
	}
	if err != nil {
		os.Exit(1)
	}
	if config.Quiet {
		logOutput = ioutil.Discard
	}
	log.SetPrefix("[exec  ] ")
	log.SetOutput(logOutput)
	err = run()
	if err != nil {
		log.Println("failed:", err)
		os.Exit(2)
	}
}

func runApplication(ctx context.Context, msg *amqp.Delivery) ([]byte, error) {
	cmd := exec.CommandContext(ctx, config.Args.App, config.Args.Params...)
	cmd.Env = append(cmd.Env,
		"MESSAGE_ID="+msg.MessageId,
		"MESSAGE_TYPE="+msg.Type,
		"CONTENT_TYPE="+msg.ContentType,
		"SUBJECT="+msg.RoutingKey,
		"TIMESTAMP="+strconv.FormatInt(msg.Timestamp.Unix(), 10),
		"CORRELATION_ID="+msg.CorrelationId,
	)
	for name, value := range msg.Headers {
		cmd.Env = append(cmd.Env, name+"="+fmt.Sprint(value))
	}
	buffer := &bytes.Buffer{}
	cmd.Stderr = os.Stderr
	cmd.Stdout = io.MultiWriter(buffer, os.Stdout)
	cmd.Stdin = bytes.NewBuffer(msg.Body)
	err := cmd.Run()
	if err != nil {
		return nil, err
	}
	return buffer.Bytes(), nil
}
