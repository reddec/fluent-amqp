package main

import (
	"bufio"
	"bytes"
	"context"
	"fmt"
	"github.com/jessevdk/go-flags"
	"github.com/pkg/errors"
	"github.com/reddec/fluent-amqp"
	"github.com/streadway/amqp"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"strconv"
	"time"
)

var (
	version = "dev"
)
var config struct {
	URLs            []string          `short:"u" long:"url"                env:"BROKER_URL"         description:"One or more AMQP brokers urls" default:"amqp://guest:guest@localhost" required:"yes"`
	Exchange        string            `short:"e" long:"exchange"           env:"BROKER_EXCHANGE"    description:"Name of AMQP exchange. Can be empty"`
	ExchangeType    string            `short:"k" long:"kind"               env:"BROKER_KIND"        description:"Exchange kind" choice:"direct" choice:"topic" choice:"fanout" default:"direct"`
	Verify          string            `short:"s" long:"verify-public-cert" env:"BROKER_SIGN"        description:"Path to public cert to verify"`
	Queue           string            `short:"Q" long:"queue"              env:"BROKER_QUEUE"       description:"Queue name or empty for autogenerated"`
	Lazy            bool              `short:"l" long:"lazy"               env:"BROKER_LAZY"        description:"Make queue lazy (prefer keep data on disk)"`
	Interval        time.Duration     `short:"R" long:"reconnect-interval" env:"BROKER_RECONNECT_INTERVAL" description:"Reconnect timeout" default:"5s"`
	RetryLimit      int               `long:"retry-limit" env:"RETRY_LIMIT" description:"Number of retries (-1 is infinite)" default:"-1"`
	RetryInterval   time.Duration     `long:"retry-interval" env:"RETRY_INTERVAL" description:"Delay between attempts" default:"5s"`
	Timeout         time.Duration     `short:"T" long:"timeout" env:"BROKER_CONNECT_TIMEOUT" description:"Connect timeout" default:"30s"`
	Quiet           bool              `short:"q" long:"quiet" env:"BROKER_QUIET" description:"Suppress all log messages"`
	Version         bool              `short:"v" long:"version" description:"Print version and exit"`
	RoutingKey      []string          `short:"r" long:"routing-key"  env-delim:"," env:"BROKER_ROUTING_KEY" description:"Routing key"`
	PubExchange     string            `short:"E" long:"pub-exchange" env:"PUB_EXCHANGE" description:"Default publishing exchange"`
	PubExchangeType string            `short:"K" long:"pub-exchange-type" env:"PUB_EXCHANGE_TYPE" description:"Default publishing exchange type" choice:"direct" choice:"topic" choice:"fanout" default:"direct"`
	PubKey          string            `short:"U" long:"pub-key" env:"PUB_KEY" description:"Default publishing key"`
	PubEmpty        bool              `long:"pub-empty" env:"PUB_EMPTY" description:"Allow publish empty messages"`
	PubHeader       map[string]string `short:"H" long:"pub-header" env:"PUB_HEADER" env-delim:"," description:"Custom headers that should be added to the output message"`
	Multiline       bool              `short:"M" long:"multiline" env:"MULTILINE" description:"Use each line of output as single message"`
	Args            struct {
		App    string   `positional-arg-name:"application" env:"APP" description:"Application executable" required:"yes"`
		Params []string `positional-arg-name:"params" env:"PARAMS" env-delim:" "  description:"Application executable params"`
	} `positional-args:"yes"`
}

var logOutput io.Writer = os.Stderr

func run() error {
	gctx, cancel := context.WithCancel(context.Background())
	ctx := fluent.SignalContext(gctx)
	broker := fluent.Broker(config.URLs...).Context(ctx).Logger(log.New(logOutput, "[broker] ", log.LstdFlags)).Interval(config.Interval).Timeout(config.Timeout).Start()
	defer broker.WaitToFinish()
	defer cancel()
	log.Println("preparing sink")
	consumerConfig := broker.Sink(config.Queue).Retries(config.RetryLimit).Requeue(config.RetryInterval)
	if config.Verify != "" {
		log.Println("preparing validator")
		consumerConfig = consumerConfig.Validate(config.Verify)
	}
	if config.Lazy {
		consumerConfig = consumerConfig.Lazy()
	}

	var exchange *fluent.Exchange
	var publisher *fluent.Writer
	var autoReply = config.PubKey != ""
	if config.PubKey != "" {
		var publisherConfig = broker.Publisher().DefaultKey(config.PubKey)
		if config.PubExchange != "" {
			switch config.PubExchangeType {
			case "topic":
				publisherConfig = publisherConfig.DefaultTopic(config.PubExchange)
			case "direct":
				publisherConfig = publisherConfig.DefaultDirect(config.PubExchange)
			case "fanout":
				publisherConfig = publisherConfig.DefaultFanout(config.PubExchange)
			default:
				return errors.Errorf("unknown exchange type %v", config.PubExchangeType)
			}
		}
		publisher = publisherConfig.Create()
	} else {
		publisher = broker.Publisher().Create()
	}

	if config.Exchange != "" {
		switch config.ExchangeType {
		case "topic":
			exchange = consumerConfig.Topic(config.Exchange)
		case "direct":
			exchange = consumerConfig.Direct(config.Exchange)
		case "fanout":
			exchange = consumerConfig.Fanout(config.Exchange)
		default:
			return errors.Errorf("unknown exchange type %v", config.ExchangeType)
		}
		exchange = exchange.Key(config.RoutingKey...)

		exchange.TransactFunc(makeHandler(publisher, autoReply, config.PubEmpty, config.Multiline, config.PubHeader))
	} else {
		// direct consuming without binding to exchange
		consumerConfig.TransactFunc(makeHandler(publisher, autoReply, config.PubEmpty, config.Multiline, config.PubHeader))
	}
	log.Println("reader prepared")
	log.Println("waiting for messages...")
	broker.WaitToFinish()
	return nil
}

func makeHandler(publisher *fluent.Writer, autoReply, emptyPublish bool, multiLine bool, headers map[string]string) fluent.TransactionHandlerFunc {
	h := &handler{multiLine: multiLine, emptyPublish: emptyPublish, publisher: publisher, autoReply: autoReply, headers: headers}
	return h.Handle
}

type handler struct {
	autoReply    bool
	emptyPublish bool
	multiLine    bool
	headers      map[string]string
	publisher    *fluent.Writer
}

func (h *handler) send(ctx context.Context, msg *amqp.Delivery, data []byte) error {
	if len(data) == 0 && !h.emptyPublish {
		// skip empty data
		return nil
	}
	var out *fluent.Message
	if msg.ReplyTo != "" {
		out = h.publisher.Reply(msg).Bytes(data)
	} else if h.autoReply {
		out = h.publisher.Prepare().Bytes(data)
	}
	if out != nil {
		for k, v := range h.headers {
			out = out.Header(k, v)
		}
		return out.PublishWait(ctx)
	}
	return nil
}

func (h *handler) Handle(ctx context.Context, msg amqp.Delivery) error {
	if h.multiLine {
		scanner, err := runMultiLineApplication(ctx, &msg)
		if err != nil {
			return err
		}
		for scanner.Scan() {
			data := scanner.Bytes()
			err = h.send(ctx, &msg, data)
			if err != nil {
				return err
			}
		}
	} else {
		data, err := runApplication(ctx, &msg)
		if err != nil {
			return err
		}
		return h.send(ctx, &msg, data)
	}
	return nil
}

func main() {
	parser := flags.NewParser(&config, flags.Default)
	_, err := parser.Parse()
	if config.Version {
		fmt.Println(version)
		return
	}
	if err != nil {
		os.Exit(1)
	}
	if config.Quiet {
		logOutput = ioutil.Discard
	}
	log.SetPrefix("[exec  ] ")
	log.SetOutput(logOutput)
	err = run()
	if err != nil {
		log.Println("failed:", err)
		os.Exit(2)
	}
}

func runApplication(ctx context.Context, msg *amqp.Delivery) ([]byte, error) {
	cmd := makeCmd(ctx, msg)
	buffer := &bytes.Buffer{}
	cmd.Stderr = os.Stderr
	cmd.Stdout = io.MultiWriter(buffer, os.Stdout)
	cmd.Stdin = bytes.NewBuffer(msg.Body)
	err := cmd.Run()
	if err != nil {
		return nil, err
	}
	return buffer.Bytes(), nil
}

func runMultiLineApplication(ctx context.Context, msg *amqp.Delivery) (*bufio.Scanner, error) {
	cmd := makeCmd(ctx, msg)

	r, w := io.Pipe()
	lineScanner := bufio.NewScanner(r)

	cmd.Stderr = os.Stderr
	cmd.Stdout = io.MultiWriter(w, os.Stdout)
	cmd.Stdin = bytes.NewBuffer(msg.Body)
	err := cmd.Start()
	if err != nil {
		r.Close()
		w.Close()
		return nil, err
	}

	go func() {
		cmd.Wait()
		r.Close()
		w.Close()
	}()
	return lineScanner, nil
}

func makeCmd(ctx context.Context, msg *amqp.Delivery) *exec.Cmd {
	cmd := exec.CommandContext(ctx, config.Args.App, config.Args.Params...)
	cmd.Env = append(cmd.Env,
		"MESSAGE_ID="+msg.MessageId,
		"MESSAGE_TYPE="+msg.Type,
		"CONTENT_TYPE="+msg.ContentType,
		"SUBJECT="+msg.RoutingKey,
		"TIMESTAMP="+strconv.FormatInt(msg.Timestamp.Unix(), 10),
		"CORRELATION_ID="+msg.CorrelationId,
	)
	for name, value := range msg.Headers {
		cmd.Env = append(cmd.Env, name+"="+fmt.Sprint(value))
	}
	return cmd
}
