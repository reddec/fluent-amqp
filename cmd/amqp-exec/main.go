package main

import (
	"bytes"
	"context"
	"fmt"
	"github.com/jessevdk/go-flags"
	"github.com/pkg/errors"
	"github.com/reddec/fluent-amqp"
	"github.com/streadway/amqp"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"strconv"
	"time"
)

var (
	version = "dev"
)
var config struct {
	URLs            []string      `short:"u" long:"url"                env:"BROKER_URL"         description:"One or more AMQP brokers urls" default:"amqp://guest:guest@localhost" required:"yes"`
	Exchange        string        `short:"e" long:"exchange"           env:"BROKER_EXCHANGE"    description:"Name of AMQP exchange. Can be empty"`
	ExchangeType    string        `short:"k" long:"kind"               env:"BROKER_KIND"        description:"Exchange kind" choice:"direct" choice:"topic" choice:"fanout" default:"direct"`
	Verify          string        `short:"s" long:"verify-public-cert" env:"BROKER_SIGN"        description:"Path to public cert to verify"`
	Queue           string        `short:"Q" long:"queue"              env:"BROKER_QUEUE"       description:"Queue name or empty for autogenerated"`
	Lazy            bool          `short:"l" long:"lazy"               env:"BROKER_LAZY"        description:"Make queue lazy (prefer keep data on disk)"`
	Interval        time.Duration `short:"R" long:"reconnect-interval" env:"BROKER_RECONNECT_INTERVAL" description:"Reconnect timeout" default:"5s"`
	RetryLimit      int           `long:"retry-limit" env:"RETRY_LIMIT" description:"Number of retries (-1 is infinite)" default:"-1"`
	RetryInterval   time.Duration `long:"retry-interval" env:"RETRY_INTERVAL" description:"Delay between attempts" default:"5s"`
	Timeout         time.Duration `short:"T" long:"timeout" env:"BROKER_CONNECT_TIMEOUT" description:"Connect timeout" default:"30s"`
	Quiet           bool          `short:"q" long:"quiet" env:"BROKER_QUIET" description:"Suppress all log messages"`
	Version         bool          `short:"v" long:"version" description:"Print version and exit"`
	RoutingKey      []string      `short:"r" long:"routing-key"  env-delim:"," env:"BROKER_ROUTING_KEY" description:"Routing key"`
	PubExchange     string        `short:"E" long:"pub-exchange" env:"PUB_EXCHANGE" description:"Default publishing exchange"`
	PubExchangeType string        `short:"K" long:"pub-exchange-type" env:"PUB_EXCHANGE_TYPE" description:"Default publishing exchange type" choice:"direct" choice:"topic" choice:"fanout" default:"direct"`
	PubKey          string        `short:"U" long:"pub-key" env:"PUB_KEY" description:"Default publishing key"`
	PubEmpty        bool          `long:"pub-empty" env:"PUB_EMPTY" description:"Allow publish empty messages"`
	Args            struct {
		App    string   `positional-arg-name:"application" env:"APP" description:"Application executable" required:"yes"`
		Params []string `positional-arg-name:"params" env:"PARAMS" env-delim:" "  description:"Application executable params"`
	} `positional-args:"yes"`
}

var logOutput io.Writer = os.Stderr

func run() error {
	gctx, cancel := context.WithCancel(context.Background())
	ctx := fluent.SignalContext(gctx)
	broker := fluent.Broker(config.URLs...).Context(ctx).Logger(log.New(logOutput, "[broker] ", log.LstdFlags)).Interval(config.Interval).Timeout(config.Timeout).Start()
	defer broker.WaitToFinish()
	defer cancel()
	log.Println("preparing sink")
	consumerConfig := broker.Sink(config.Queue).Retries(config.RetryLimit).Requeue(config.RetryInterval)
	if config.Verify != "" {
		log.Println("preparing validator")
		consumerConfig = consumerConfig.Validate(config.Verify)
	}
	if config.Lazy {
		consumerConfig = consumerConfig.Lazy()
	}

	var exchange *fluent.Exchange
	var publisher *fluent.Writer
	var autoReply = config.PubKey != ""
	if config.PubKey != "" {
		var publisherConfig = broker.Publisher().DefaultKey(config.PubKey)
		if config.PubExchange != "" {
			switch config.PubExchangeType {
			case "topic":
				publisherConfig = publisherConfig.DefaultTopic(config.PubExchange)
			case "direct":
				publisherConfig = publisherConfig.DefaultDirect(config.PubExchange)
			case "fanout":
				publisherConfig = publisherConfig.DefaultFanout(config.PubExchange)
			default:
				return errors.Errorf("unknown exchange type %v", config.PubExchangeType)
			}
		}
		publisher = publisherConfig.Create()
	} else {
		publisher = broker.Publisher().Create()
	}

	if config.Exchange != "" {
		switch config.ExchangeType {
		case "topic":
			exchange = consumerConfig.Topic(config.Exchange)
		case "direct":
			exchange = consumerConfig.Direct(config.Exchange)
		case "fanout":
			exchange = consumerConfig.Fanout(config.Exchange)
		default:
			return errors.Errorf("unknown exchange type %v", config.ExchangeType)
		}
		exchange = exchange.Key(config.RoutingKey...)

		exchange.TransactFunc(makeHandler(publisher, autoReply, config.PubEmpty))
	} else {
		// direct consuming without binding to exchange
		consumerConfig.TransactFunc(makeHandler(publisher, autoReply, config.PubEmpty))
	}
	log.Println("reader prepared")
	log.Println("waiting for messages...")
	broker.WaitToFinish()
	return nil
}

func makeHandler(publisher *fluent.Writer, autoReply, emptyPublish bool) fluent.TransactionHandlerFunc {
	return func(ctx context.Context, msg amqp.Delivery) error {
		data, err := runApplication(ctx, &msg)
		if err != nil {
			return err
		}
		if len(data) == 0 && !emptyPublish {
			// skip empty data
			return nil
		}
		if msg.ReplyTo != "" {
			return publisher.Reply(&msg).Bytes(data).PublishWait(ctx)
		} else if autoReply {
			return publisher.Prepare().Bytes(data).PublishWait(ctx)
		}
		return nil
	}
}

func main() {
	parser := flags.NewParser(&config, flags.Default)
	_, err := parser.Parse()
	if config.Version {
		fmt.Println(version)
		return
	}
	if err != nil {
		os.Exit(1)
	}
	if config.Quiet {
		logOutput = ioutil.Discard
	}
	log.SetPrefix("[exec  ] ")
	log.SetOutput(logOutput)
	err = run()
	if err != nil {
		log.Println("failed:", err)
		os.Exit(2)
	}
}

func runApplication(ctx context.Context, msg *amqp.Delivery) ([]byte, error) {
	cmd := exec.CommandContext(ctx, config.Args.App, config.Args.Params...)
	cmd.Env = append(cmd.Env,
		"MESSAGE_ID="+msg.MessageId,
		"MESSAGE_TYPE="+msg.Type,
		"CONTENT_TYPE="+msg.ContentType,
		"SUBJECT="+msg.RoutingKey,
		"TIMESTAMP="+strconv.FormatInt(msg.Timestamp.Unix(), 10),
		"CORRELATION_ID="+msg.CorrelationId,
	)
	for name, value := range msg.Headers {
		cmd.Env = append(cmd.Env, name+"="+fmt.Sprint(value))
	}
	buffer := &bytes.Buffer{}
	cmd.Stderr = os.Stderr
	cmd.Stdout = io.MultiWriter(buffer, os.Stdout)
	cmd.Stdin = bytes.NewBuffer(msg.Body)
	err := cmd.Run()
	if err != nil {
		return nil, err
	}
	return buffer.Bytes(), nil
}
