package fluent

import (
	"context"
	"fmt"
	"github.com/streadway/amqp"
	"net"
	"regexp"
	"sync"
	"time"
)

var maskPassword = regexp.MustCompile(`[^/:]+:([^@:]+)@`)

type StateHandler interface {
	ChannelReady(ctx context.Context, ch *amqp.Channel) error
}

// Handler for sinks to catch expired messages (see SinkConfig OnExpired and OnTooMuchRetries)
type DefaultSinkExpiredHandler func(ctx context.Context, sinkName string, msg amqp.Delivery, retries int64) bool

// Server keeps broker configuration and all declared objects (queues, exchanges and else) for re-declare after restart
type Server struct {
	config          BrokerConfig
	handlersLock    sync.Mutex
	handlers        []StateHandler
	refreshHandlers chan struct{}
	done            chan struct{}
	urlIndex        int
}

func (brk *Server) handle(st StateHandler) *Server {
	brk.handlersLock.Lock()
	brk.handlers = append(brk.handlers, st)
	brk.handlersLock.Unlock()
	select {
	case brk.refreshHandlers <- struct{}{}:
	default:

	}
	return brk
}

// Sink creates new AMQP consumer with optional queue name. If queue name is empty - autogenerated one will be used without
// persistence. Max retries by default is 10
func (brk *Server) Sink(queueName string) *SinkConfig {
	return newSink(queueName, brk)
}

// Publisher creates new AMQP producer
func (brk *Server) Publisher() *WriterConfig {
	return newWriter(brk)
}

// Requeue creates new queue for requeue-ing. New name constructed by default as [originalQueue]/requeue.
// For example: original queue is SAMPLE, than requeue queue is SAMPLE/requeue
func (brk *Server) Requeue(originalQueue string) *ReQueueConfig {
	return newRequeue(brk, originalQueue)
}

//Wait to finish blocks thread un=til all allocated resources become freed
func (brk *Server) WaitToFinish() {
	<-brk.done
}

func (brk *Server) start() error {
	defer close(brk.done)
	brk.onReady()
	for {
		if err := brk.onIdle(); err != nil {
			return err
		}
	}
}

// IDLE - wait before next circle, returns error if context closed. Can cause READY state
func (brk *Server) onIdle() error {
	brk.config.logger.Println("try to reconnect after", brk.config.reconnectInterval)
	select {
	case <-time.After(brk.config.reconnectInterval):
		brk.onReady()
	case <-brk.config.ctx.Done():
		brk.config.logger.Println("reconnect aborted due to context close")
		return brk.config.ctx.Err()
	}
	return nil
}

// READY - ready to connect, may cause DISCONNECT or CONNECTION_ESTABLISHED state
func (brk *Server) onReady() {
	conn, err := brk.dialToFirstReachable()
	if err != nil {
		brk.config.logger.Println("failed to connect to broker:", err)
	} else {
		brk.onConnectionEstablished(conn)
		_ = conn.Close()
		brk.onDisconnected()
	}
}

// CONNECTION_ESTABLISHED connection established and ready. May cause CHANNEL_CREATED and CHANNELS_CREATED
func (brk *Server) onConnectionEstablished(conn *amqp.Connection) {
	childContext, closer := context.WithCancel(brk.config.ctx)
	defer closer()
	wg := sync.WaitGroup{}
	// create connections for each handlers (could be added dynamically)
	for handler := range brk.streamHandlers(childContext) {
		wg.Add(1)
		go func(handler StateHandler) {
			defer wg.Done()
			defer closer() // <-- close all other channels
			channel, err := brk.createChannel(conn)
			if err != nil {
				brk.config.logger.Println("failed create channel:", err)
				return
			}
			defer channel.Close()
			brk.onChannelCreated(childContext, channel, handler)
		}(handler)
	}
	brk.onChannelsCreated(childContext)
	wg.Wait()
}

// CHANNEL_CREATED channel is ready to process, terminate state
func (brk *Server) onChannelCreated(ctx context.Context, channel *amqp.Channel, handler StateHandler) {
	err := handler.ChannelReady(ctx, channel)
	if err != nil {
		brk.config.logger.Println("failed handler:", err)
	}
}

// CHANNELS_CREATED all channels tried to be initialized, terminate state
func (brk *Server) onChannelsCreated(ctx context.Context) {
	// for future development
}

// DISCONNECTED connection is closed, terminate state
func (brk *Server) onDisconnected() {
	// for future development
}

func (brk *Server) createChannel(conn *amqp.Connection) (*amqp.Channel, error) {
	ch, err := conn.Channel()
	if err != nil {
		stringErr := fmt.Sprintf("%s", err)
		brk.config.logger.Println("failed open channel:", maskPassword.ReplaceAllString(stringErr, "***@"))
		return nil, err
	}
	err = ch.Qos(1, 0, true)
	if err != nil {
		_ = ch.Close()
		brk.config.logger.Println("failed set QoS:", err)
		return nil, err
	}
	return ch, nil
}

func (brk *Server) dialToFirstReachable() (*amqp.Connection, error) {
	for _, url := range brk.config.urls {
		brk.config.logger.Println("connecting to", maskPassword.ReplaceAllString(url, "***@"))
		conn, err := amqp.DialConfig(url, amqp.Config{
			Heartbeat: 10 * time.Second,
			Locale:    "en_US",
			Dial: func(network, addr string) (net.Conn, error) {
				d := net.Dialer{
					KeepAlive: 10 * time.Second,
				}
				cctx, closer := context.WithTimeout(brk.config.ctx, brk.config.connectTimeout)
				defer closer()
				return d.DialContext(cctx, network, addr)
			},
		})
		if err != nil {
			stringErr := fmt.Sprintf("%s", err)
			brk.config.logger.Println("connection error:", maskPassword.ReplaceAllString(stringErr, "***@"))
		} else {
			brk.config.logger.Println("successfully connected to", maskPassword.ReplaceAllString(url, "***@"))
			return conn, nil
		}
		if brk.config.ctx.Err() != nil {
			return nil, brk.config.ctx.Err()
		}
	}
	return nil, fmt.Errorf("all urls are unreachable")
}

func (brk *Server) streamHandlers(ctx context.Context) <-chan StateHandler {
	out := make(chan StateHandler)
	go func() {
		defer close(out)
		var num int
		for {
			targetNum := len(brk.handlers)
			for i := num; i < targetNum; i++ {
				select {
				case <-ctx.Done():
					return
				case out <- brk.handlers[i]:
				}
			}
			num = targetNum
			select {
			case <-ctx.Done():
				return
			case <-brk.refreshHandlers:

			}
		}
	}()
	return out
}
